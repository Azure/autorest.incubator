import { NodeProc, NodePhi, ControlSource, ControlSink, ControlFlow, Graph, SymbolSource, SymbolSink, DataFlow } from "./graph";
import { setIsEqual, setIsSubset, setExcept, error } from "./helpers";
import { ProcDefinitions, GraphProblem, SymbolInstance } from "./graph-context";
import { getSymbolSourceType, getSymbolSinkType, getSymbolSourceOf } from "./graph-analysis";

function validateSymbolLink<TType>(graph: Graph<TType>, procs: ProcDefinitions<TType>, src: SymbolSource<TType>, sink: SymbolSink<TType>, typeAssignableTo: (from: TType, to: TType) => boolean, onProblem: (problem: GraphProblem) => void): void {
  const sourceType = getSymbolSourceType(graph.inputs, procs, src);
  const sinkType = getSymbolSinkType(graph.outputFlows, procs, sink);
  if (sourceType === undefined) {
    onProblem({ severity: "error", message: `Symbol source of input '${sink.id}' not found.`, graphComponent: sink.target, needsHumanIntervention: true });
    return;
  }
  if (sinkType === undefined) {
    return error("invalid symbol sink (generated by this program...)");
  }
  if (!typeAssignableTo(sourceType, sinkType))
    onProblem({ severity: "error", message: `Symbol source of input '${sink.id}' has type conflicting type.`, graphComponent: sink.target, needsHumanIntervention: true });
}

export function validateNodePhi<TType>(n: NodePhi<TType>, onProblem: (problem: GraphProblem) => void): void {

}

export function validateNodeProc<TType>(n: NodeProc<TType>, procs: ProcDefinitions<TType>, onProblem: (problem: GraphProblem) => void): void {
  // proc exists
  const id = n.procID;
  const proc = procs[id];
  if (proc === undefined) {
    onProblem({ severity: "error", message: `Procedure '${id}' not found.`, graphComponent: n, needsHumanIntervention: true });
    return;
  }
}

export function validateRawControlFlow<TType>(rawEdges: ReadonlyArray<ControlFlow<TType>>, controlSourceNorm: (x: ControlSource<TType>) => ControlSource<TType> | undefined, controlSinkNorm: (x: ControlSink<TType>) => ControlSink<TType> | undefined, onProblem: (p: GraphProblem) => void): void {
  // edges point to existing sources and sinks?
  for (const edge of rawEdges) {
    if (controlSourceNorm(edge.source) === undefined)
      onProblem({ severity: "error", message: `Source of control flow edge does not exist.`, graphComponent: edge, needsHumanIntervention: true });
    if (controlSinkNorm(edge.target) === undefined)
      onProblem({ severity: "error", message: `Sink of control flow edge does not exist.`, graphComponent: edge, needsHumanIntervention: true });
  }
}

export function validateControlFlow<TType>(edges: ReadonlyArray<ControlFlow<TType>>, controlSources: Iterable<ControlSource<TType>>, controlSinks: Iterable<ControlSink<TType>>, onProblem: (p: GraphProblem) => void): void {
  // number of connections
  for (const x of controlSources) {
    const adjacent = edges.filter(f => f.source === x).length;
    if (adjacent > 1) onProblem({ severity: "error", message: `More than one outgoing control flow.`, graphComponent: x, needsHumanIntervention: true });
    if (adjacent < 1) onProblem({ severity: "error", message: `No outgoing control flow.`, graphComponent: x, needsHumanIntervention: false });
  }
  for (const x of controlSinks) {
    const adjacent = edges.filter(f => f.target === x).length;
    if (adjacent > 1) onProblem({ severity: "error", message: `More than one incoming control flow.`, graphComponent: x, needsHumanIntervention: false });
    if (adjacent < 1) onProblem({ severity: "warning", message: `No incoming control flow.`, graphComponent: x, needsHumanIntervention: false });
  }
}

export function validateRawDataFlow<TType>(dataFlow: ReadonlyArray<DataFlow<TType>>, procs: ProcDefinitions<TType>, symbolSinks: Iterable<SymbolSink<TType>>, symbolSourceNorm: (x: SymbolSource<TType>) => SymbolSource<TType> | undefined, symbolSinkNorm: (x: SymbolSink<TType>) => SymbolSink<TType> | undefined, onProblem: (p: GraphProblem) => void): void {
  // symbol source exists?
  for (const sink of symbolSinks) {
    let src = getSymbolSourceOf(dataFlow, sink, symbolSinkNorm);
    if (src === undefined) onProblem({ severity: "error", message: `Symbol sink '${sink.id}' unconnected.`, graphComponent: sink.target, needsHumanIntervention: false });
    else {
      src = symbolSourceNorm(src);
      if (src === undefined) onProblem({ severity: "error", message: `Symbol source of '${sink.id}' does not exist.`, graphComponent: sink.target, needsHumanIntervention: true });
    }
  }
}

export function validateDataFlow<TType>(graph: Graph<TType>, procs: ProcDefinitions<TType>, edges: ReadonlyArray<DataFlow<TType>>, symbolSources: Iterable<SymbolSource<TType>>, symbolSinks: Iterable<SymbolSink<TType>>, typeAssignableTo: (from: TType, to: TType) => boolean, onProblem: (p: GraphProblem) => void): void {
  for (const edge of edges)
    validateSymbolLink(graph, procs, edge.source, edge.target, typeAssignableTo, onProblem);
  // number of connections
  for (const x of symbolSources) {
    const adjacent = edges.filter(f => f.source === x).length;
    if (adjacent < 1) onProblem({ severity: "warning", message: `No outgoing data flow.`, graphComponent: x, needsHumanIntervention: false });
  }
  for (const x of symbolSinks) {
    const adjacent = edges.filter(f => f.target === x).length;
    if (adjacent > 1) onProblem({ severity: "error", message: `More than one incoming data flow.`, graphComponent: x, needsHumanIntervention: false });
    if (adjacent < 1) onProblem({ severity: "warning", message: `No incoming data flow.`, graphComponent: x, needsHumanIntervention: false });
  }
}

export function validateSymbolAvailability<TType>(edges: Iterable<ControlFlow<TType>>, supply: ReadonlyMap<ControlSource<TType>, ReadonlySet<SymbolInstance<TType>>>, demand: ReadonlyMap<ControlSink<TType>, ReadonlySet<SymbolInstance<TType>>>, onProblem: (p: GraphProblem) => void): void {
  for (const edge of edges) {
    const a = supply.get(edge.source);
    const b = demand.get(edge.target);
    if (a === undefined || b === undefined) return error("supply/demand incomplete");
    const except = [...setExcept(b, a)];
    if (except.length !== 0)
      onProblem({ severity: "error", message: `Symbols '${except.map(x => x.source.id).join(', ')}' not available.`, graphComponent: edge.target, needsHumanIntervention: false });
  }
}